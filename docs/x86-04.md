### 中断和异常

#### 基础
1. [中断的定义与种类](https://lrita.github.io/2019/03/05/linux-interrupt-and-trap)
1. 中断：又称为异步中断（I/O设备或者时钟引起的），分为两种：
  * 可屏蔽中断，I/O设备发出的都是可屏蔽中断，控制单元可以忽略它。
  * 非屏蔽中断，例如硬件故障，非屏蔽中断总是由CPU辨认。
1. 异常：又称为同步中断，分为四种：
  * 故障（fault），通常可以纠正，一旦纠正，程序就可以重新开始
  * 陷阱（trap），如系统调用
  * 异常终止（abort），发生严重错误，这种异常会强制中止进程。
  * 编程异常（programmed exception）
1. linux中之所以为每一个cpu提供一个TSS段，而不是为每个进程提供一个TSS段，主要原因是tr寄存器永远指向它，没有切cpu不必切换tr寄存器，从而减小开销。

#### 中断触发
1. 通过中断向量号i读取IDTR寄存器指向的IDT表中的第i项门描述符，检查DPL权限。
1. 从GDTR寄存器获得GDT的基地址，并在GDT中查找，以读取IDT表项中的选择符所标识的段描述符，这个描述符指定中断或异常处理程序所在的段的基地址。
1. 检查是否发生了特权等级变化。如果是由用户态陷入了内核态，控制单元必须开始使用与新的特权级相关的堆栈 
  1. 读TR寄存器，访问运行进程的TSS段。
  2. 用与新特权级相关的栈段和栈指针装载ss和esp寄存器。这些值可以在进程的TSS段中找到。 
  3. 在新的栈（内核栈）中保存用户态的ss和esp，这些值指明了用户态相关栈的逻辑地址。
    * 为什么在内核栈保存用户态的状态？
    * 原因1：如果在用户态保存这些状态，ss和esp可能被修改；保存在内核态，内核还会检查ss和esp是否合法。
    * 原因2：内核态返回的时候是用iret指令弹出ss和esp，保存在内核态更安全。
1. 如果故障已经发生，用引起异常的指令地址装载cs和eip寄存器，从而使这条指令能够再次被执行。
1. 在栈中保存eflags、cs以及eip的内容。
1. 如果异常产生了一个硬件出错码，则保存在栈中。
1. 装载cs和eip寄存器，其值分别是IDT表中的第i项门描述符的段选择符和偏移量，执行中断回调函数。

#### 中断返回
1. 用保存在栈中的值装载cs、eip或eflags寄存器，如果一个硬件出错码曾被押入栈中，并且在eip内容上面，那么执行iret指令必须先弹出这个硬件出错码。
1. 检查处理程序的CPL是否等于cs中的最低两位的值，如果是，说明在同一特权级，iret中止执行，否则转入下一步。
1. 从栈中装载ss和esp寄存器，返回到与旧特权级相关的栈。
1. 检查ds、es、fs以及gs段寄存器的内容，如果其中一个寄存器包含的选择符是个段描述符，并且其DPL值小于CPL，那么就清除相应的段寄存器。
