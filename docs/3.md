### x86架构操作系统内核的实现

#### 参考资料
1. [x86架构操作系统内核的实现](http://wiki.0xffffff.org/)

#### hurlex <四> 字符模式下的显卡驱动
1. 内存的前1M地址：
  * 0xB8000～0xC0000：文本模式的显存，屏幕被划分为25行，每行可以显示80个字符，一屏可以显示2000个字符

#### hurlex <五> 相关库函数和调试打印函数
1. [Linux C中内联汇编的语法格式及使用方法](https://blog.csdn.net/slvher/article/details/8864996)


```
asm [ volatile ] (  
         assembler template
         [ : output operands ]                /* optional */
         [ : input operands  ]                /* optional */
         [ : list of clobbered registers ]    /* optional */
);
1. volatile关键字表示不要对汇编代码做任何优化
2. %%reg表示寄存器%reg
3. output operands：=r表示寄存器约束，=m表示内存约束，https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints
  * r寄存器约束：先把值赋给寄存器，再赋值。还可以指定寄存器：
    * a : %eax, %ax, %al
    * b : %ebx, %bx, %bl
    * c : %ecx, %cx, %cl
    * d : %edx, %dx, %dl
    * S : %esi, %si
    * D : %edi, %di
  * m内存约束：不想通过寄存器中转，直接操作内存
  * 0关联约束：例如asm("incl %0" : "=a"(var) : "0"(var)); 指定都用%eax作为中转寄存器
4. input operands：r表示寄存器约束
5. list of clobbered registers：告诉编译器，内联汇编可能用到这些寄存器
```

#### hurlex <六> 添加全局段描述符表
1. GDT表只有5个：基址都是0，limit长度都是4G
  1. 按照 Intel 文档要求，第一个描述符必须全 0
  1. 内核代码段
  1. 内核数据段
  1. 用户模式代码段
  1. 用户模式数据段
1. 打印GDT表：print /x gdt_entries
1. 打印GDT表内存位置：print &gdt_entries
1. 查看全局变量的内存位置：readelf -s hx_kernel //其中Value列就是。
1. 查看6个段寄存器的值：info registers。其中CS=0x08，其他段=0x10
  * 段寄存器16位：前13位是segment selector，1位是TI（Table Indicator），2位是RPL（Requested Privilege Level）
  * 0x08：前13位是1，TI=0，RPL=0
  * 0x10：前13位是2，TI=0，RPL=0
  * 貌似本章之前的实验，cpu的6个段寄存器的值就是这样的，只是这个时候没有GDT表

#### hurlex <七> 添加中断描述符表
1. NASM编译器的宏定义用法：[我的汇编学习之路（5）](http://idiotsky.top/2016/05/16/asm-learning-road-5/)
1. 中断处理过程：
  * cpu每执行一条指令就检查是否有中断请求（带中断向量），以中断向量为索引在IDT中找到段选择子
  * 通过段选择子在GDT中找到段描述符，检查DPL、CPL、RPL，如果发生特权切换，则涉及TSS段和用户栈和内核栈的切换

```c
%macro ISR_NOERRCODE 1
[GLOBAL isr%1]
isr%1:
    push %1
%endmacro
// 其中第一行的1表示只有一个参数，用%1来表示。当调用ISR_NOERRCODE 34，即表示生成如下代码：
[GLOBAL isr34]
isr34:
    push 34
```

#### hurlex <八> 完成中断请求和定时器中断
1. 异常中断isr 0 ~ 19：
  * void isr0();        // 0 #DE 除 0 异常 
  * void isr1();        // 1 #DB 调试异常 
  * void isr2();        // 2 NMI 
  * void isr3();        // 3 BP 断点异常 
  * void isr4();        // 4 #OF 溢出 
  * void isr5();        // 5 #BR 对数组的引用超出边界 
  * void isr6();        // 6 #UD 无效或未定义的操作码 
  * void isr7();        // 7 #NM 设备不可用(无数学协处理器) 
  * void isr8();        // 8 #DF 双重故障(有错误代码) 
  * void isr9();        // 9 协处理器跨段操作 
  * void isr10();       // 10 #TS 无效TSS(有错误代码) 
  * void isr11();       // 11 #NP 段不存在(有错误代码) 
  * void isr12();       // 12 #SS 栈错误(有错误代码) 
  * void isr13();       // 13 #GP 常规保护(有错误代码) 
  * void isr14();       // 14 #PF 页故障(有错误代码) 
  * void isr15();       // 15 CPU 保留 
  * void isr16();       // 16 #MF 浮点处理单元错误 
  * void isr17();       // 17 #AC 对齐检查 
  * void isr18();       // 18 #MC 机器检查 
  * void isr19();       // 19 #XM SIMD(单指令多数据)浮点异常
1. 异常中断isr 20 ~ 31：Intel 保留
1. 硬件中断irq 32 ~ 47：
  * \#define  IRQ0     32    // 电脑系统计时器
  * \#define  IRQ1     33    // 键盘
  * \#define  IRQ2     34    // 与 IRQ9 相接，MPU-401 MD 使用
  * \#define  IRQ3     35    // 串口设备
  * \#define  IRQ4     36    // 串口设备
  * \#define  IRQ5     37    // 建议声卡使用
  * \#define  IRQ6     38    // 软驱传输控制使用
  * \#define  IRQ7     39    // 打印机传输控制使用
  * \#define  IRQ8     40    // 即时时钟
  * \#define  IRQ9     41    // 与 IRQ2 相接，可设定给其他硬件
  * \#define  IRQ10    42    // 建议网卡使用
  * \#define  IRQ11    43    // 建议 AGP 显卡使用
  * \#define  IRQ12    44    // 接 PS/2 鼠标，也可设定给其他硬件
  * \#define  IRQ13    45    // 协处理器使用
  * \#define  IRQ14    46    // IDE0 传输控制使用
  * \#define  IRQ15    47    // IDE1 传输控制使用





