### x86架构操作系统内核的实现

#### 参考资料
1. [x86架构操作系统内核的实现](http://wiki.0xffffff.org/)

#### hurlex <四> 字符模式下的显卡驱动
1. 内存的前1M地址：
  * 0xB8000～0xC0000：文本模式的显存，屏幕被划分为25行，每行可以显示80个字符，一屏可以显示2000个字符

#### hurlex <五> 相关库函数和调试打印函数
1. [Linux C中内联汇编的语法格式及使用方法](https://blog.csdn.net/slvher/article/details/8864996)


```
asm [ volatile ] (  
         assembler template
         [ : output operands ]                /* optional */
         [ : input operands  ]                /* optional */
         [ : list of clobbered registers ]    /* optional */
);
1. volatile关键字表示不要对汇编代码做任何优化
2. %%reg表示寄存器%reg
3. output operands：=r表示寄存器约束，=m表示内存约束，https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints
  * r寄存器约束：先把值赋给寄存器，再赋值。还可以指定寄存器：
    * a : %eax, %ax, %al
    * b : %ebx, %bx, %bl
    * c : %ecx, %cx, %cl
    * d : %edx, %dx, %dl
    * S : %esi, %si
    * D : %edi, %di
  * m内存约束：不想通过寄存器中转，直接操作内存
  * 0关联约束：例如asm("incl %0" : "=a"(var) : "0"(var)); 指定都用%eax作为中转寄存器
4. input operands：r表示寄存器约束
5. list of clobbered registers：告诉编译器，内联汇编可能用到这些寄存器
```

#### hurlex <六> 添加全局段描述符表
1. GDT表只有5个：基址都是0，limit长度都是4G
  1. 按照 Intel 文档要求，第一个描述符必须全 0
  1. 内核代码段
  1. 内核数据段
  1. 用户模式代码段
  1. 用户模式数据段
1. 打印GDT表：print /x gdt_entries
1. 打印GDT表内存位置：print &gdt_entries
1. 查看全局变量的内存位置：readelf -s hx_kernel //其中Value列就是。
1. 查看6个段寄存器的值：info registers。其中CS=0x08，其他段=0x10
  * 段寄存器16位：前13位是segment selector，1位是TI（Table Indicator），2位是RPL（Requested Privilege Level）
  * 0x08：前13位是1，TI=0，RPL=0
  * 0x10：前13位是2，TI=0，RPL=0
  * 貌似本章之前的实验，cpu的6个段寄存器的值就是这样的，只是这个时候没有GDT表

#### hurlex <七> 添加中断描述符表
1. NASM编译器的宏定义用法：[我的汇编学习之路（5）](http://idiotsky.top/2016/05/16/asm-learning-road-5/)
1. 中断处理过程：
  * cpu每执行一条指令就检查是否有中断请求（带中断向量），以中断向量为索引在IDT中找到段选择子
  * 通过段选择子在GDT中找到段描述符，检查DPL、CPL、RPL，如果发生特权切换，则涉及TSS段和用户栈和内核栈的切换

```c
%macro ISR_NOERRCODE 1
[GLOBAL isr%1]
isr%1:
    push %1
%endmacro
// 其中第一行的1表示只有一个参数，用%1来表示。当调用ISR_NOERRCODE 34，即表示生成如下代码：
[GLOBAL isr34]
isr34:
    push 34
```

















