### xv6源码学习

#### 参考资料
1. [xv6 中文文档](https://th0ar.gitbooks.io/xv6-chinese/)
  
#### 第0章 操作系统接口
1. 操作系统的工作是：
  * (1)将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身更有用的服务。
  * (2)管理并抽象底层硬件，举例来说，程序不用去关心自己使用的是何种硬盘。
  * (3)多路复用硬件，使得多个程序可以(至少看起来是)同时运行的。
  * (4)最后，给程序间提供一种受控的交互方式，使得程序之间可以共享数据、共同工作。
1. 按照 Unix 的术语来说，所有的 xv6 进程都以 root 用户执行
1. 文件描述符的种类：
  * 文件系统：文件或者目录
  * 网卡设备
  * 管道（pipe）
  * 输入输出
1. echo hello world | wc 可以用无管道的方式实现：echo hello world > /tmp/xyz; wc < /tmp/xyz。区别在：
  1. 管道会进行自我清扫，如果是 shell 重定向的话，在任务完成后删除 /tmp/xyz。
  1. 管道可以传输任意长度的数据。
  1. 管道允许同步：每一个读操作都阻塞调用进程，直到另一个进程用write完成数据的发送。
1. xv6的shell命令都是用户程序，诸如mkdir、ln、rm等等，只有cd例外。

#### 第1章 第一个进程
1. 小技巧：make -B强制重新编译（即使文件没有变化）
1. xv6.img的组成：
  * bootblock: bootasm.S、bootmain.c。开启A20；实模式到保护模式；从磁盘读取kernel（ELF32文件）并执行
  * kernel: 
    * entry.S：入口文件，设置临时页表，开启分页，调用main()
    * main.c：管理物理页、设置页表、多核启动（AP执行的是entryother.S）；调用proc.c的userinit()
    * proc.c：userinit()创建了一个进程，执行的是initcode.S
    * bio.c
    * console.c
    * exec.c
    * file.c
    * fs.c
    * ide.c
    * ioapic.c
    * kalloc.c
    * kbd.c
    * lapic.c
    * log.c
    * mp.c
    * picirq.c
    * pipe.c
    * sleeplock.c
    * spinlock.c
    * string.c
    * swtch.S
    * syscall.c
    * sysfile.c
    * sysproc.c
    * trapasm.S
    * trap.c
    * uart.c
    * vectors.S
    * vm.c
    * entryother.S：作为二进制文件；最后调用main.c的mpenter()
    * initcode.S：作为二进制文件；最后执行系统调用sys_exec('/init', 0)
1. fs.img的组成
    * _init：init.c ulib.c usys.S printf.c umalloc.c。先fork()再执行/sh
    * _sh：sh.c ulib.c usys.c printf.c umalloc.c。shell脚本，支持重定向和管道
    * _cat 
    * _echo 
    * _forktest 
    * _grep 
    * _kill 
    * _ln 
    * _ls 
    * _mkdir 
    * _rm 
    * _stressfs 
    * _usertests 
    * _wc 
    * _zombie

#### 第1章 第一个进程的启动流程
1. [xv6 book Chapter1 总结+课后习题](https://zhuanlan.zhihu.com/p/40228846)
1. 内核态：第一个进程p加入到进程列表ptable.proc后，cpu执行scheduler()找到它，然后恢复p->context到寄存器。
1. 内核态：此时的p->context->eip指向forkret()，forkret执行完跳到trapret，trapret的iret跳到用户态。
1. 用户态：iret时，trapframe中的eip值为0，而第一个进程已将initcode.S的text拷贝到了va=0的地方了。

#### 第2章 页表
1. 全局常量KERNBASE：0x80000000；KERNBASE以上是内核空间
1. 全局常量DEVSPACE：0xFE000000；I/O Hole
1. 全局常量PHYSTOP：0x0E000000；PHYSTOP以下是物理地址，共224MB
1.  PTE的标志位：
  * PTE_P 表示PTE是否陈列在页表中
  * PTE_W 控制着能否对页执行写操作
  * PTE_U 控制着用户程序能否使用该页
1. 进程的用户内存从 0 开始，最多能够增长到 KERNBASE, 这使得一个进程最多只能使用 2GB 的内存。
  * KERNBASE 之上的页对应的 PTE 中，PTE_U 位均被置 0
1. xv6 会把没有被使用的 PTE 的 PTE_P 标志位设为 0
1. 每个进程的页表同时包括用户内存和内核内存的映射，这样用户态和内核态转换的时候就不需要切换页表。
1. 在没有设置页表之前：使用临时页表
  * VA's [0x000000, 0x000000+4MB) to PA's [0, 4MB)
  * VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
1. 内核的页表映射：main.c的kvmalloc()
  * VA's [KERNBASE, ......... KERNBASE+1MB) ..... to PA's [0, 1MB) // I/O space
  * VA's [KERNBASE+1MB, ..... KERNBASE+V2P(data)) to PA's [1MB,V2P(data)) // kern text+rodata
  * VA's [KERNBASE+V2P(data), PHYSTOP) .......... to PA's [V2P(data),PHYSTOP) // kern data+memory
  * VA's [DEVSPACE, ......... DEVSPACE+4K) ...... to PA's [DEVSPACE,DEVSPACE+4K) // more devices
1. 用户的页表映射：initcode.S
  * VA's [0, 0+4KB) ..... to PA's [一页物理页) // initcode.S代码


```
用qemu的info pg命令观察页表：
1.在没有设置页表之前：使用临时页表
VPN range     Entry         Flags        Physical page
[00000-003ff]  PDE[000]     --S-A---WP 00000-003ff 
[80000-803ff]  PDE[200]     --S-A---WP 00000-003ff
虚拟地址后加000，即为：
[00000000-003ff000] -> 00000000-003ff000
[80000000-803ff000] -> 00000000-003ff000

2.内核的页表映射
VPN range     Entry         Flags        Physical page
[80000-803ff]  PDE[200]     ----A--UWP
  [80000-800ff]  PTE[000-0ff] --------WP 00000-000ff
  [80100-80101]  PTE[100-101] ---------P 00100-00101
  [80102-80102]  PTE[102]     ----A----P 00102
  [80103-80105]  PTE[103-105] ---------P 00103-00105
  [80106-80106]  PTE[106]     ----A----P 00106
  [80107-80107]  PTE[107]     ---------P 00107
  [80108-8010a]  PTE[108-10a] --------WP 00108-0010a
  [8010b-8010b]  PTE[10b]     ----A---WP 0010b
  [8010c-803ff]  PTE[10c-3ff] --------WP 0010c-003ff
[80400-8dfff]  PDE[201-237] -------UWP
  [80400-8dfff]  PTE[000-3ff] --------WP 00400-0dfff
[fe000-fffff]  PDE[3f8-3ff] -------UWP
  [fe000-fffff]  PTE[000-3ff] --------WP fe000-fffff
虚拟地址后加000，即为：
[80000000-800ff000] -> 00000000-000ff000 //I/O space
[80100000-80107000] -> 00100000-00107000 //kern text+rodata
[80108000-8dfff000] -> 00108000-0dfff000 //kern data+memory
[fe000000-fffff000] -> fe000000-fffff000 //more devices

3.用户的页表映射：initcode.S
[00000000-00000000] -> 00000000-00000000 //initcode.S
```

#### 第3章 陷入，中断和驱动程序
1. 陷入、异常和中断的三大挑战：
  * 1）内核必须使处理器能够从用户态转换到内核态（并且再转换回用户态）
  * 2）内核和设备必须协调好他们并行的活动。
  * 3）内核必须知道硬件接口的细节。
1. eflags 寄存器中的 IF 位：=1打开中断，=0关闭中断
1. xv6中的中断是指硬件中断，中断过程不允许处理其他中断，即要清除IF位
1. xv6将键盘中断分发到处理器。将磁盘中断分发到编号最大的处理器。
1. JOS的网卡没有中断，使用的轮询。硬盘没有中断，pending直到硬盘完成任务。

#### 第3章 实际情况
1. 硬盘，显卡和网卡在驱动中同样都使用直接内存访问（Direct memory access, DMA）而不是直接用 I/O(insl, outsl)
1. 本章的绝大多数设备使用 I/O 指令编程。而所有现代设备都使用内存映射 I/O （Memory-mapped I/O）来进行编程
1. 网卡的轮询和中断：
  * 对于一个收到大量包的网络设备来说，可能会从中断切换到轮询，因为它知道会到来更多的包被处理，使用轮询会降低处理它们的成本。
  * 一旦没有更多的包需要处理了，驱动可能就会切换回中断模式，使得当有新的包到来的时候能够被立刻通知
1. IDE 硬盘的驱动静态的发送中断到一个特定的处理器上。
1. 网卡可能为一个网络连接的包向处理这个连接的处理器发送一个中断。
1. 没有使用零拷贝的场景：读磁盘
  * 第一次是由驱动从硬盘拷贝到内核内存，
  * 第二次通过 read 系统调用，从内核内存拷贝到用户内存
1. IRQ列表：IRQ越小优先级越高，对应的vector要+32
  * IRQ0 ：系统时钟（不能改变）
  * IRQ1 ：键盘控制器（不能改变）
  * IRQ3 ：串口2的串口控制器（如有串口4，则其也使用这个中断）
  * IRQ4 ：串口1的串口控制器（如有串口3，则其也使用这个中断）
  * IRQ5 ：并口2和3或声卡
  * IRQ6 ：软盘控制器
  * IRQ7 : 并口1。用于打印机，没有打印机则用于任何并口
  * IRQ8 : Real time clock
  * IRQ9 : Video
  * IRQ10 : Open
  * IRQ11 : Open
  * IRQ12 : PS/2 mouse
  * IRQ13 : Coprocessor
  * IRQ14 : Primary IDE controller (hard drives)
  * IRQ15 : Secondary IDE controller (hard drives)

#### 第4章 锁
1. xchg(uint *addr, uint newval)：修改addr=newval，并返回addr的旧值
1. 锁不仅要让不同的 CPU 不会互相干扰，还需要让调用者与被调者不会互相干扰。
  * 递归锁无法保证调用者与被调者不会互相干扰？
  *（如果代码是串行执行，并没有问题，难道递归的过程也能实现并发，能想到的只有多线程、多进程）
1. xv6最长的锁链也就只有两个锁
1. acquire获取锁(调用pushcli屏蔽中断)、release释放锁(调用popcli来恢复中断)
  * 如果acquire了两次，那么在第二次release的时候才会恢复中断
  * 为什么在内核态获取锁后要屏蔽中断？
  * （假设执行 iderw 持有 idelock，然后中断发生，开始运行 ideintr。ideintr 会试图获得 idelock，但却发现 idelock 已经获取锁了）
1. 用户级程序也需要锁，但 xv6 的程序只有一个运行线程，进程间也不会共享内存，所以就不需要锁了。

#### 第5章 调度

#### 第6章 文件系统
1. [xv6 文件系统 阅读小结](https://zhuanlan.zhihu.com/p/53034996)














