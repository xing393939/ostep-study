### xv6源码学习

#### 参考资料
1. [xv6 中文文档](https://th0ar.gitbooks.io/xv6-chinese/)
  
#### 第0章 操作系统接口
1. 操作系统的工作是：
  * (1)将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身更有用的服务。
  * (2)管理并抽象底层硬件，举例来说，程序不用去关心自己使用的是何种硬盘。
  * (3)多路复用硬件，使得多个程序可以(至少看起来是)同时运行的。
  * (4)最后，给程序间提供一种受控的交互方式，使得程序之间可以共享数据、共同工作。
1. 按照 Unix 的术语来说，所有的 xv6 进程都以 root 用户执行
1. 文件描述符的种类：
  * 文件系统：文件或者目录
  * 网卡设备
  * 管道（pipe）
  * 输入输出
1. echo hello world | wc 可以用无管道的方式实现：echo hello world > /tmp/xyz; wc < /tmp/xyz。区别在：
  1. 管道会进行自我清扫，如果是 shell 重定向的话，在任务完成后删除 /tmp/xyz。
  1. 管道可以传输任意长度的数据。
  1. 管道允许同步：每一个读操作都阻塞调用进程，直到另一个进程用write完成数据的发送。
1. xv6的shell命令都是用户程序，诸如mkdir、ln、rm等等，只有cd例外。

#### 第1章 第一个进程
1. 小技巧：make -B强制重新编译（既是文件没有变化）
1. xv6.img的组成：
  * bootblock: bootasm.S、bootmain.c。开启A20；实模式到保护模式；从磁盘读取kernel（ELF32文件）并执行
  * kernel: 
    * entry.S：入口文件，设置临时页表，开启分页，调用main()
    * main.c：管理物理页、设置页表、多核启动（AP执行的是entryother.S）；调用proc.c的userinit()
    * proc.c：userinit()创建了一个进程，执行的是initcode.S
    * bio.c
    * console.c
    * exec.c
    * file.c
    * fs.c
    * ide.c
    * ioapic.c
    * kalloc.c
    * kbd.c
    * lapic.c
    * log.c
    * mp.c
    * picirq.c
    * pipe.c
    * sleeplock.c
    * spinlock.c
    * string.c
    * swtch.S
    * syscall.c
    * sysfile.c
    * sysproc.c
    * trapasm.S
    * trap.c
    * uart.c
    * vectors.S
    * vm.c
    * entryother.S：作为二进制文件；最后调用main.c的mpenter()
    * initcode.S：作为二进制文件；最后执行系统调用sys_exec('/init', 0)
1. fs.img的组成
    * _init：init.c ulib.c usys.S printf.c umalloc.c。先fork()再执行/sh
    * _sh：sh.c ulib.c usys.c printf.c umalloc.c。shell脚本，支持重定向和管道
    * _cat 
    * _echo 
    * _forktest 
    * _grep 
    * _kill 
    * _ln 
    * _ls 
    * _mkdir 
    * _rm 
    * _stressfs 
    * _usertests 
    * _wc 
    * _zombie

#### 第2章 页表
1. 全局常量KERNBASE：0x80000000；KERNBASE以上是内核空间
1. 全局常量DEVSPACE：0xFE000000；I/O Hole
1. 全局常量PHYSTOP：0xE000000；PHYSTOP以下是物理地址，共224MB
1.  PTE的标志位：
  * PTE_P 表示PTE是否陈列在页表中
  * PTE_W 控制着能否对页执行写操作
  * PTE_U 控制着用户程序能否使用该页
1. 进程的用户内存从 0 开始，最多能够增长到 KERNBASE, 这使得一个进程最多只能使用 2GB 的内存。
  * KERNBASE 之上的页对应的 PTE 中，PTE_U 位均被置 0
1. xv6 会把没有被使用的 PTE 的 PTE_P 标志位设为 0
1. 每个进程的页表同时包括用户内存和内核内存的映射，这样用户态和内核态转换的时候就不需要切换页表。
1. 在没有设置页表之前：使用临时页表
  * VA's [0x000000, 0x000000+4MB) to PA's [0, 4MB)
  * VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
1. 内核的页表映射：
  * VA's [KERNBASE, ......... KERNBASE+1MB) ..... to PA's [0, 1MB) // I/O space
  * VA's [KERNBASE+1MB, ..... KERNBASE+V2P(data)) to PA's [1MB,V2P(data)) // kern text+rodata
  * VA's [KERNBASE+V2P(data), PHYSTOP) .......... to PA's [V2P(data),PHYSTOP) // kern data+memory
  * VA's [DEVSPACE, ......... DEVSPACE+4K) ...... to PA's [DEVSPACE,DEVSPACE+4K) // more devices




